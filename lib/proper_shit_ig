// // // // lib/main.dart
// // // import 'dart:async';
// // // import 'dart:developer' as developer;
// // // import 'dart:isolate';
// // // import 'dart:io';
// // // import 'dart:math' as math;
// // // import 'package:flutter/material.dart';
// // // import 'package:path_provider/path_provider.dart';

// // // void main() {
// // //   WidgetsFlutterBinding.ensureInitialized();
// // //   runApp(const FlutterPulseApp());
// // // }

// // // // -------------------- App --------------------

// // // class FlutterPulseApp extends StatelessWidget {
// // //   const FlutterPulseApp({super.key});

// // //   @override
// // //   Widget build(BuildContext context) {
// // //     return MaterialApp(
// // //       title: 'FlutterPulse â€” Phase1 (FastPath + Workers)',
// // //       theme: ThemeData.dark(),
// // //       home: const StressTestPage(),
// // //       debugShowCheckedModeBanner: false,
// // //     );
// // //   }
// // // }

// // // // -------------------- Fast Classifier --------------------

// // // class FastClassifier {
// // //   bool isFastGesture({
// // //     required int activePointers,
// // //     required String detail,
// // //     required double computeIntensity,
// // //   }) {
// // //     if (activePointers > 1) return false;
// // //     if (computeIntensity > 0.75) return false;
// // //     if (detail == 'down' || detail == 'up') return true;
// // //     if (detail == 'move') return true;
// // //     return true;
// // //   }
// // // }

// // // // -------------------- Worker Isolate --------------------

// // // class WorkerIsolate {
// // //   Isolate? _isolate;
// // //   SendPort? _sendPort;
// // //   final ReceivePort _receivePort = ReceivePort();
// // //   Function(int seq, Map<String, dynamic> result)? onResult;

// // //   int maxOutstanding;
// // //   int sampleRate;
// // //   int _outstanding = 0;
// // //   int coalesceWindowMs;

// // //   WorkerIsolate({
// // //     this.maxOutstanding = 8,
// // //     this.sampleRate = 1,
// // //     this.coalesceWindowMs = 20,
// // //   });

// // //   Future<void> spawn({required String name, int workMultiplier = 1}) async {
// // //     final ready = Completer<void>();
// // //     final spawnPort = ReceivePort();

// // //     late StreamSubscription sub;
// // //     sub = spawnPort.listen((msg) {
// // //       if (msg is SendPort) {
// // //         _sendPort = msg;
// // //         ready.complete();
// // //         sub.cancel();
// // //       }
// // //     });

// // //     _isolate = await Isolate.spawn(_workerEntry, spawnPort.sendPort, debugName: name);

// // //     _receivePort.listen((msg) {
// // //       if (msg is Map && msg['type'] == 'result') {
// // //         final seq = msg['seq'] as int;
// // //         final result = Map<String, dynamic>.from(msg['result'] ?? {});
// // //         if (_outstanding > 0) _outstanding--;
// // //         onResult?.call(seq, result);
// // //       }
// // //     });

// // //     await ready.future;
// // //     _sendPort?.send({
// // //       'type': 'register',
// // //       'reply': _receivePort.sendPort,
// // //       'multiplier': workMultiplier
// // //     });
// // //   }

// // //   void sendEvent(int seq, Map<String, dynamic> payload) {
// // //     if (_sendPort == null) {
// // //       developer.postEvent('worker_send_failed', {'seq': seq, 'reason': 'no_send_port'});
// // //       return;
// // //     }

// // //     // sampling
// // //     if (sampleRate > 1 && (seq % sampleRate != 0)) {
// // //       developer.postEvent('worker_sampled_out', {'seq': seq});
// // //       return;
// // //     }

// // //     // coalescing by pointerId if provided (optional)
// // //     if (payload.containsKey('pointerId')) {
// // //       // simplistic coalescing not implemented here; placeholder
// // //     }

// // //     if (_outstanding >= maxOutstanding) {
// // //       developer.postEvent('worker_dropped', {'seq': seq, 'outstanding': _outstanding});
// // //       return;
// // //     }

// // //     _outstanding++;
// // //     _sendPort?.send({'type': 'event', 'seq': seq, 'payload': payload});
// // //     developer.postEvent('worker_sent', {'seq': seq, 'outstanding': _outstanding});
// // //   }

// // //   int outstanding() => _outstanding;

// // //   void kill() {
// // //     try {
// // //       _isolate?.kill(priority: Isolate.immediate);
// // //     } finally {
// // //       try {
// // //         _receivePort.close();
// // //       } catch (_) {}
// // //       _isolate = null;
// // //       _sendPort = null;
// // //     }
// // //   }

// // //   static void _workerEntry(SendPort mainReply) {
// // //     final workerReceive = ReceivePort();
// // //     mainReply.send(workerReceive.sendPort);
// // //     SendPort? uiPort;
// // //     int multiplier = 1;

// // //     workerReceive.listen((msg) {
// // //       if (msg is Map) {
// // //         if (msg['type'] == 'register') {
// // //           uiPort = msg['reply'] as SendPort?;
// // //           multiplier = msg['multiplier'] as int? ?? 1;
// // //         } else if (msg['type'] == 'event') {
// // //           final seq = msg['seq'] as int;
// // //           final payload = Map<String, dynamic>.from(msg['payload'] ?? {});
// // //           final sentTsStr = payload['sent_ts'] as String?;
// // //           DateTime? sentTs = sentTsStr != null ? DateTime.parse(sentTsStr) : null;
// // //           final start = DateTime.now();

// // //           // Simulate heavy compute proportional to multiplier
// // //           int acc = 0;
// // //           final count = 250000 * multiplier;
// // //           for (int i = 0; i < count; i++) {
// // //             acc ^= (i * 37) % 1234567;
// // //           }

// // //           final end = DateTime.now();
// // //           final workMs = end.difference(start).inMilliseconds;
// // //           final queuedMs = sentTs != null ? start.difference(sentTs).inMilliseconds : -1;

// // //           uiPort?.send({
// // //             'type': 'result',
// // //             'seq': seq,
// // //             'result': {
// // //               'work_ms': workMs,
// // //               'queued_ms': queuedMs,
// // //               'acc': acc,
// // //               'worker': 'iso-$multiplier',
// // //               'worker_ts': end.toIso8601String(),
// // //             }
// // //           });
// // //         }
// // //       }
// // //     }, onError: (e, st) {
// // //       mainReply.send({'type': 'worker_error', 'error': e.toString()});
// // //     });
// // //   }
// // // }

// // // // -------------------- Profiler --------------------

// // // class EventProfiler {
// // //   int _seq = 0;
// // //   final Map<int, DateTime> _pending = {};
// // //   final List<_Sample> samples = [];
// // //   final int maxSamples = 20000;

// // //   int recordInputEvent({String detail = ''}) {
// // //     final id = ++_seq;
// // //     _pending[id] = DateTime.now();
// // //     developer.postEvent('input_event', {'seq': id, 'detail': detail});
// // //     return id;
// // //   }

// // //   void onFramePainted() {
// // //     final now = DateTime.now();
// // //     final keys = _pending.keys.toList();
// // //     for (final k in keys) {
// // //       final start = _pending.remove(k);
// // //       if (start != null) {
// // //         final latencyMs = now.difference(start).inMilliseconds;
// // //         samples.add(_Sample(seq: k, latencyMs: latencyMs, ts: start));
// // //         developer.postEvent('input_painted', {'seq': k, 'latency_ms': latencyMs});
// // //       }
// // //     }
// // //     if (samples.length > maxSamples) {
// // //       samples.removeRange(0, samples.length - maxSamples);
// // //     }
// // //   }

// // //   Map<String, int> computePercentiles({int window = 1000}) {
// // //     if (samples.isEmpty) return {'p50': 0, 'p95': 0, 'p99': 0};
// // //     final use = samples.length < window
// // //         ? samples.map((s) => s.latencyMs).toList()
// // //         : samples.sublist(samples.length - window).map((s) => s.latencyMs).toList();
// // //     use.sort();
// // //     int at(double p) {
// // //       final idx = ((use.length - 1) * p).floor();
// // //       return use[math.max(0, math.min(use.length - 1, idx))];
// // //     }

// // //     return {'p50': at(0.50), 'p95': at(0.95), 'p99': at(0.99)};
// // //   }

// // //   Future<String> exportCsv(List<Map<String, dynamic>> workerRows) async {
// // //     final dir = await getApplicationDocumentsDirectory();
// // //     final file = File('${dir.path}/flutterpulse_phase1_${DateTime.now().millisecondsSinceEpoch}.csv');
// // //     final sink = file.openWrite();
// // //     sink.writeln('seq,ts,latency_ms,worker,queued_ms,work_ms');
// // //     for (final s in samples) {
// // //       final matching = workerRows.firstWhere((r) => r['seq'] == s.seq, orElse: () => {});
// // //       final worker = matching['worker'] ?? '';
// // //       final queued = matching['queued_ms'] ?? '';
// // //       final work = matching['work_ms'] ?? '';
// // //       sink.writeln('${s.seq},${s.ts.toIso8601String()},${s.latencyMs},$worker,$queued,$work');
// // //     }
// // //     await sink.flush();
// // //     await sink.close();
// // //     developer.postEvent('export_csv', {'path': file.path});
// // //     return file.path;
// // //   }
// // // }

// // // class _Sample {
// // //   final int seq;
// // //   final DateTime ts;
// // //   final int latencyMs;
// // //   _Sample({required this.seq, required this.ts, required this.latencyMs});
// // // }

// // // // -------------------- CPU heavy helper --------------------

// // // class CpuHeavy {
// // //   static int doHeavyWork(int tris, {int multiplier = 1}) {
// // //     final rnd = math.Random(54321);
// // //     double acc = 0.0;
// // //     final loops = (tris * multiplier).clamp(1000, 100000000);
// // //     for (int t = 0; t < loops; t++) {
// // //       acc += rnd.nextDouble() * (t % 7 + 1);
// // //     }
// // //     return acc.toInt();
// // //   }
// // // }

// // // // -------------------- Main Page --------------------

// // // class StressTestPage extends StatefulWidget {
// // //   const StressTestPage({super.key});

// // //   @override
// // //   State<StressTestPage> createState() => _StressTestPageState();
// // // }

// // // class _StressTestPageState extends State<StressTestPage> with SingleTickerProviderStateMixin {
// // //   final EventProfiler profiler = EventProfiler();
// // //   final FastClassifier classifier = FastClassifier();

// // //   final List<Offset> _points = [];
// // //   late AnimationController _animationController;

// // //   // control state
// // //   double _graphicsSliderValue = 0.5;
// // //   double _computeIntensity = 0.5;
// // //   bool _enableHeavyDraw = true;
// // //   bool _busyBlockEnabled = false;
// // //   int _busyBlockMs = 40;
// // //   bool _busyBlockPerFrame = false;

// // //   bool _useOffload = false;
// // //   bool _useTwoWorkers = false;

// // //   int _numSpheres = 200;
// // //   List<double> rotationSpeeds = [];
// // //   List<double> phaseOffsets = [];

// // //   WorkerIsolate? workerHeavy;
// // //   WorkerIsolate? workerVeryHeavy;
// // //   List<Map<String, dynamic>> workerResults = [];

// // //   int heavyDone = 0;
// // //   int veryHeavyDone = 0;

// // //   final List<int> _rawLatency = [];
// // //   static const int maxSamples = 12;

// // //   int _lastUpdateTime = 0;

// // //   @override
// // //   void initState() {
// // //     super.initState();
// // //     _animationController = AnimationController(vsync: this, duration: const Duration(seconds: 10))..repeat();
// // //     _applyGraphicsAndComputeSettings();

// // //     _animationController.addListener(() {
// // //       if (_busyBlockPerFrame) _blockUiFor(_busyBlockMs);
// // //     });
// // //   }

// // //   @override
// // //   void dispose() {
// // //     _animationController.dispose();
// // //     workerHeavy?.kill();
// // //     workerVeryHeavy?.kill();
// // //     super.dispose();
// // //   }

// // //   void _applyGraphicsAndComputeSettings() {
// // //     final minSpheres = 20;
// // //     final maxSpheres = 1200;
// // //     _numSpheres = (minSpheres + (_graphicsSliderValue * (maxSpheres - minSpheres))).round();
// // //     final rnd = math.Random(42);
// // //     rotationSpeeds = List<double>.generate(_numSpheres, (_) => rnd.nextDouble() * 3 + 0.5);
// // //     phaseOffsets = List<double>.generate(_numSpheres, (_) => rnd.nextDouble() * 2 * math.pi);
// // //   }

// // //   void _recordLatency(int micros) {
// // //     setState(() {
// // //       _rawLatency.insert(0, (micros / 1000).round());
// // //       if (_rawLatency.length > maxSamples) _rawLatency.removeLast();
// // //     });
// // //   }

// // //   void _blockUiFor(int ms) {
// // //     final sw = Stopwatch()..start();
// // //     var x = 0.0;
// // //     while (sw.elapsedMilliseconds < ms) {
// // //       x += math.sqrt((sw.elapsedMilliseconds + 1) * 1.0001);
// // //       if (x > 1e12) x = 0.0;
// // //     }
// // //     sw.stop();
// // //   }

// // //   void _simulateHeavyDrawing() {
// // //     if (!_enableHeavyDraw) return;
// // //     final rnd = math.Random(1337);
// // //     final intensityFactor = (_computeIntensity * 18.0) + 1.0;
// // //     final outer = (40 * intensityFactor).round();
// // //     final inner = (200 * intensityFactor).round();
// // //     var acc = 0.0;
// // //     for (int i = 0; i < outer; i++) {
// // //       final base = (i + 1).toDouble();
// // //       for (int j = 0; j < inner; j++) {
// // //         final val = (base * (j + 1) + rnd.nextDouble());
// // //         acc += math.sqrt(val) * math.sin(val) * math.cos(val * 0.0001);
// // //       }
// // //     }
// // //     if (acc.isInfinite) {}
// // //   }

// // //   Future<void> _ensureWorkersSpawned() async {
// // //     if (workerHeavy == null) {
// // //       workerHeavy = WorkerIsolate(maxOutstanding: 8);
// // //       workerHeavy!.onResult = _onWorkerResult;
// // //       await workerHeavy!.spawn(name: 'worker-heavy', workMultiplier: 1);
// // //       developer.postEvent('worker_spawned', {'name': 'heavy'});
// // //     }
// // //     if (_useTwoWorkers && workerVeryHeavy == null) {
// // //       workerVeryHeavy = WorkerIsolate(maxOutstanding: 8);
// // //       workerVeryHeavy!.onResult = _onWorkerResult;
// // //       await workerVeryHeavy!.spawn(name: 'worker-very-heavy', workMultiplier: 4);
// // //       developer.postEvent('worker_spawned', {'name': 'very-heavy'});
// // //     }
// // //   }

// // //   void _onWorkerResult(int seq, Map<String, dynamic> res) {
// // //     workerResults.add({
// // //       'seq': seq,
// // //       'worker': res['worker'],
// // //       'queued_ms': res['queued_ms'],
// // //       'work_ms': res['work_ms'],
// // //     });
// // //     setState(() {
// // //       if ((res['worker'] ?? '').toString().contains('4')) veryHeavyDone++;
// // //       else heavyDone++;
// // //     });
// // //     developer.postEvent('worker_result', res);
// // //   }

// // //   Future<void> _routeEvent(int seq, String detail, Offset pos) async {
// // //     final isFast = classifier.isFastGesture(activePointers: 1, detail: detail, computeIntensity: _computeIntensity);

// // //     if (isFast) {
// // //       // fast path - immediate cheap work
// // //       developer.postEvent('fast_path', {'seq': seq});
// // //       // still simulate some UI painting work
// // //       _simulateHeavyDrawing(); // optional: remove if you want pure fast path
// // //       return;
// // //     }

// // //     // heavy path
// // //     if (!_useOffload) {
// // //       // run on UI thread (blocks) to show baseline
// // //       final start = DateTime.now();
// // //       CpuHeavy.doHeavyWork((_computeIntensity * 50000).round() + 1000);
// // //       final end = DateTime.now();
// // //       developer.postEvent('heavy_on_ui', {'seq': seq, 'ms': end.difference(start).inMilliseconds});
// // //       return;
// // //     }

// // //     // offload
// // //     await _ensureWorkersSpawned();
// // //     final payload = {
// // //       'type': detail,
// // //       'x': pos.dx,
// // //       'y': pos.dy,
// // //       'sent_ts': DateTime.now().toIso8601String(),
// // //     };

// // //     final chooseVery = _computeIntensity > 0.85;
// // //     if (_useTwoWorkers && chooseVery && workerVeryHeavy != null) {
// // //       workerVeryHeavy!.sendEvent(seq, payload);
// // //     } else {
// // //       workerHeavy!.sendEvent(seq, payload);
// // //     }
// // //   }

// // //   Future<void> _exportCsv() async {
// // //     final path = await profiler.exportCsv(workerResults);
// // //     if (!mounted) return;
// // //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Exported CSV: $path')));
// // //   }

// // //   @override
// // //   Widget build(BuildContext context) {
// // //     _applyGraphicsAndComputeSettings();
// // //     final stats = profiler.computePercentiles(window: 1000);

// // //     return Scaffold(
// // //       appBar: AppBar(
// // //         title: const Text('FlutterPulse â€” Phase1 (FastPath + 2 Workers)'),
// // //         actions: [
// // //           TextButton(onPressed: _exportCsv, child: const Text('Export CSV')),
// // //         ],
// // //       ),



// import 'dart:async';
// import 'dart:collection';
// import 'dart:isolate';
// import 'dart:math' as math;
// import 'package:flutter/material.dart';

// void main() => runApp(const MaterialApp(home: FastPathPhase2Demo()));

// class FastPathPhase2Demo extends StatefulWidget {
//   const FastPathPhase2Demo({super.key});
//   @override
//   State<FastPathPhase2Demo> createState() => _FastPathPhase2DemoState();
// }

// class _FastPathPhase2DemoState extends State<FastPathPhase2Demo> {
//   // Drawing state
//   final List<Offset> _points = [];

//   // Latency measurements
//   final List<int> latencies = [];
//   static const int maxLatSamples = 60;

//   // Gesture tracking
//   int _gestureIdCounter = 0;
//   int _seqCounter = 0;
//   final Map<int, String> _gestureStates = {}; // gestureId -> "active"/"cancelled"/"done"
//   final Map<int, int> _lastSeq = {}; // gestureId -> last applied seq

//   // Coalescing + backpressure
//   final Queue<Map<String, dynamic>> _outgoingQueue = Queue();
//   static const int maxQueueSize = 8;
//   int _lastCoalesceTime = 0;
//   static const int coalesceWindowMs = 8;

//   // Isolate communication
//   Isolate? _worker;
//   SendPort? _workerPort;
//   final ReceivePort _uiReceivePort = ReceivePort();

//   // Classifier
//   late final FastClassifier _classifier;

//   // Mode toggle
//   bool useFastPath = true;
//   int _currentGestureId = -1;

//   @override
//   void initState() {
//     super.initState();
//     _classifier = FastClassifier();
//     _spawnWorker();
//   }

//   @override
//   void dispose() {
//     _worker?.kill(priority: Isolate.immediate);
//     _uiReceivePort.close();
//     super.dispose();
//   }

//   Future<void> _spawnWorker() async {
//     final ready = Completer<SendPort>();
//     _worker = await Isolate.spawn(_workerEntry, _uiReceivePort.sendPort);

//     _uiReceivePort.listen((msg) {
//       if (msg is SendPort) {
//         _workerPort = msg;
//         ready.complete(msg);
//       } else {
//         _onWorkerMessage(msg);
//       }
//     });

//     _workerPort = await ready.future;
//   }

//   void _onWorkerMessage(dynamic msg) {
//     if (msg is! Map) return;
//     final int gestureId = msg['gestureId'];
//     final int seq = msg['seq'];
//     final int latency = msg['latency'];
//     final bool isFinal = msg['isFinal'];

//     // Validate gesture state and seq freshness
//     if (_gestureStates[gestureId] != 'active') return;
//     if (seq < (_lastSeq[gestureId] ?? -1)) return;

//     _lastSeq[gestureId] = seq;

//     setState(() {
//       latencies.insert(0, latency);
//       if (latencies.length > maxLatSamples) latencies.removeLast();
//     });

//     if (isFinal) _gestureStates[gestureId] = 'done';
//   }

//   void _sendToWorker(Map<String, dynamic> msg) {
//     if (_outgoingQueue.length >= maxQueueSize) {
//       _outgoingQueue.removeFirst(); // backpressure: drop oldest
//     }
//     _outgoingQueue.add(msg);
//     _workerPort?.send(_outgoingQueue.removeFirst());
//   }

//   void _handlePointerDown(PointerDownEvent e) {
//     _gestureIdCounter++;
//     _currentGestureId = _gestureIdCounter;
//     _gestureStates[_currentGestureId] = 'active';
//     _classifier.reset();
//   }

//   void _handlePointerMove(PointerMoveEvent e) {
//     final now = DateTime.now().millisecondsSinceEpoch;
//     if (now - _lastCoalesceTime < coalesceWindowMs) return;
//     _lastCoalesceTime = now;

//     final sw = Stopwatch()..start();

//     setState(() {
//       _points.add(e.localPosition);
//       if (_points.length > 800) _points.removeRange(0, _points.length - 800);
//     });

//     final classification = _classifier.classify(e);
//     final seq = ++_seqCounter;

//     if (!useFastPath) {
//       // ðŸ§± Baseline path: simulate heavy blocking work directly on UI thread
//       _simulateHeavyBlocking();
//     } else if (classification == GestureType.heavy) {
//       // âš¡ Fast path: offload heavy work to worker isolate
//       final msg = {
//         'gestureId': _currentGestureId,
//         'seq': seq,
//         'type': 'move',
//         'dx': e.localDelta.dx,
//         'dy': e.localDelta.dy,
//       };
//       _sendToWorker(msg);
//     }

//     WidgetsBinding.instance.addPostFrameCallback((_) {
//       sw.stop();
//       final ms = sw.elapsedMilliseconds;
//       setState(() {
//         latencies.insert(0, ms);
//         if (latencies.length > maxLatSamples) latencies.removeLast();
//       });
//     });
//   }

//   void _handlePointerUp(PointerUpEvent e) {
//     final gestureId = _currentGestureId;
//     _gestureStates[gestureId] = 'cancelled';
//     _sendToWorker({
//       'gestureId': gestureId,
//       'seq': ++_seqCounter,
//       'type': 'end',
//       'isFinal': true,
//     });
//   }

//   // ðŸ§± heavy blocking simulation for baseline mode
//   void _simulateHeavyBlocking() {
//     final sw = Stopwatch()..start();
//     double acc = 0;
//     while (sw.elapsedMilliseconds < 35) {
//       for (int i = 0; i < 4000; i++) {
//         acc += math.sqrt(i * 1.2345);
//       }
//     }
//     if (acc.isNaN) debugPrint('');
//   }

//   int _percentile(List<int> a, double p) {
//     if (a.isEmpty) return 0;
//     final sorted = List<int>.from(a)..sort();
//     final idx = ((sorted.length - 1) * p).round();
//     return sorted[idx];
//   }

//   @override
//   Widget build(BuildContext context) {
//     final sorted = [...latencies]..sort();
//     final p50 = _percentile(sorted, 0.50);
//     final p55 = _percentile(sorted, 0.55);
//     final p95 = _percentile(sorted, 0.95);
//     final p99 = _percentile(sorted, 0.99);

//     return Scaffold(
//       backgroundColor: Colors.black,
//       appBar: AppBar(
//         title: Text(useFastPath
//             ? 'âš¡ Fast Path (Phase 2)'
//             : 'ðŸ§± Baseline â€” Heavy on UI'),
//         actions: [
//           TextButton(
//             onPressed: () => setState(() {
//               latencies.clear();
//               useFastPath = !useFastPath;
//             }),
//             child: Text(
//               useFastPath ? 'Switch to Baseline' : 'Switch to Fast Path',
//               style: const TextStyle(color: Colors.white),
//             ),
//           ),
//         ],
//       ),
//       body: Stack(
//         children: [
//           Listener(
//             onPointerDown: _handlePointerDown,
//             onPointerMove: _handlePointerMove,
//             onPointerUp: _handlePointerUp,
//             child: CustomPaint(
//               painter: DrawPainter(_points),
//               child: Container(color: Colors.transparent),
//             ),
//           ),
//           Positioned(
//             top: 20,
//             right: 20,
//             child: Container(
//               padding: const EdgeInsets.all(8),
//               decoration: BoxDecoration(
//                 color: useFastPath
//                     ? Colors.greenAccent.withOpacity(0.3)
//                     : Colors.redAccent.withOpacity(0.3),
//                 borderRadius: BorderRadius.circular(6),
//               ),
//               child: Text(
//                 useFastPath ? 'FAST PATH ACTIVE' : 'BASELINE MODE',
//                 style: const TextStyle(
//                     fontFamily: 'monospace',
//                     fontWeight: FontWeight.bold,
//                     color: Colors.white),
//               ),
//             ),
//           ),
//           Positioned(
//             bottom: 20,
//             left: 20,
//             child: Container(
//               padding: const EdgeInsets.all(12),
//               width: 340,
//               decoration: BoxDecoration(
//                 color: Colors.white10,
//                 borderRadius: BorderRadius.circular(8),
//               ),
//               child: DefaultTextStyle(
//                 style: const TextStyle(fontFamily: 'monospace'),
//                 child: Column(
//                   crossAxisAlignment: CrossAxisAlignment.start,
//                   children: [
//                     Text('Latency p50/p55/p95/p99: $p50 / $p55 / $p95 / $p99 ms'),
//                     const SizedBox(height: 6),
//                     Text('Samples: ${latencies.take(10).join(', ')}'),
//                     const SizedBox(height: 10),
//                     Text('Active gestures: ${_gestureStates.keys.length}'),
//                     const SizedBox(height: 10),
//                     ElevatedButton(
//                       onPressed: () => setState(() => latencies.clear()),
//                       child: const Text('Clear Samples'),
//                     ),
//                   ],
//                 ),
//               ),
//             ),
//           ),
//         ],
//       ),
//     );
//   }
// }

// // ---------------- FastClassifier ----------------
// enum GestureType { light, heavy }

// class FastClassifier {
//   Offset? lastPos;
//   int lastTime = 0;

//   GestureType classify(PointerEvent e) {
//     final now = DateTime.now().millisecondsSinceEpoch;
//     final dt = (now - lastTime).clamp(1, 1000);
//     lastTime = now;

//     if (lastPos == null) {
//       lastPos = e.localPosition;
//       return GestureType.light;
//     }

//     final dx = (e.localPosition - lastPos!).distance;
//     lastPos = e.localPosition;
//     final velocity = dx / dt;
//     final isHeavy = velocity < 0.05 || dx > 40;
//     return isHeavy ? GestureType.heavy : GestureType.light;
//   }

//   void reset() {
//     lastPos = null;
//     lastTime = 0;
//   }
// }

// // ---------------- Worker isolate ----------------
// void _workerEntry(SendPort sendPort) {
//   final port = ReceivePort();
//   sendPort.send(port.sendPort);

//   port.listen((msg) {
//     if (msg is Map) {
//       final int gestureId = msg['gestureId'] ?? 0;
//       final int seq = msg['seq'] ?? 0;
//       final bool isFinal = msg['isFinal'] ?? false;

//       final sw = Stopwatch()..start();
//       double acc = 0;
//       for (int i = 0; i < 800000; i++) {
//         acc += math.sqrt(i + gestureId + seq);
//       }
//       sw.stop();

//       sendPort.send({
//         'gestureId': gestureId,
//         'seq': seq,
//         'latency': sw.elapsedMilliseconds,
//         'isFinal': isFinal,
//       });
//     }
//   });
// }

// // ---------------- Painter ----------------
// class DrawPainter extends CustomPainter {
//   final List<Offset> pts;
//   DrawPainter(this.pts);

//   @override
//   void paint(Canvas c, Size s) {
//     final p = Paint()
//       ..color = Colors.blueAccent.withOpacity(0.5)
//       ..strokeWidth = 3
//       ..strokeCap = StrokeCap.round;
//     for (int i = 1; i < pts.length; i++) {
//       c.drawLine(pts[i - 1], pts[i], p);
//     }
//   }

//   @override
//   bool shouldRepaint(covariant DrawPainter oldDelegate) => true;
// }

import 'dart:async';
import 'dart:collection';
import 'dart:isolate';
import 'dart:math' as math;
import 'package:flutter/material.dart';

void main() => runApp(const MaterialApp(home: FastPathPhase2Demo()));

class FastPathPhase2Demo extends StatefulWidget {
  const FastPathPhase2Demo({super.key});
  @override
  State<FastPathPhase2Demo> createState() => _FastPathPhase2DemoState();
}

class _FastPathPhase2DemoState extends State<FastPathPhase2Demo>
    with SingleTickerProviderStateMixin {
  // Drawing state
  final List<Offset> _points = [];

  // Latency measurements
  final List<int> latencies = [];
  static const int maxLatSamples = 60;

  // Gesture tracking
  int _gestureIdCounter = 0;
  int _seqCounter = 0;
  final Map<int, String> _gestureStates = {}; // gestureId -> "active"/"cancelled"/"done"
  final Map<int, int> _lastSeq = {}; // gestureId -> last applied seq

  // Coalescing + backpressure
  final Queue<Map<String, dynamic>> _outgoingQueue = Queue();
  static const int maxQueueSize = 8;
  int _lastCoalesceTime = 0;
  static const int coalesceWindowMs = 8;

  // Isolate communication
  Isolate? _worker;
  SendPort? _workerPort;
  final ReceivePort _uiReceivePort = ReceivePort();

  // Classifier
  late final FastClassifier _classifier;

  // Mode toggle
  bool useFastPath = true;
  int _currentGestureId = -1;

  // GPU stress spheres
  late AnimationController _animationController;
  int numSpheres = 200;
  final List<double> rotationSpeeds = [];
  final List<double> phaseOffsets = [];

  @override
  void initState() {
    super.initState();
    _classifier = FastClassifier();
    _spawnWorker();

    // animation for GPU spheres
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 10),
    )..repeat();

    // precompute random rotation params
    for (int i = 0; i < 400; i++) {
      rotationSpeeds.add(math.Random(42 + i).nextDouble() * 3 + 0.5);
      phaseOffsets.add(math.Random(99 + i).nextDouble() * 2 * math.pi);
    }
  }

  @override
  void dispose() {
    _worker?.kill(priority: Isolate.immediate);
    _uiReceivePort.close();
    _animationController.dispose();
    super.dispose();
  }

  Future<void> _spawnWorker() async {
    final ready = Completer<SendPort>();
    _worker = await Isolate.spawn(_workerEntry, _uiReceivePort.sendPort);

    _uiReceivePort.listen((msg) {
      if (msg is SendPort) {
        _workerPort = msg;
        ready.complete(msg);
      } else {
        _onWorkerMessage(msg);
      }
    });

    _workerPort = await ready.future;
  }

  void _onWorkerMessage(dynamic msg) {
    if (msg is! Map) return;
    final int gestureId = msg['gestureId'];
    final int seq = msg['seq'];
    final int latency = msg['latency'];
    final bool isFinal = msg['isFinal'];

    if (_gestureStates[gestureId] != 'active') return;
    if (seq < (_lastSeq[gestureId] ?? -1)) return;
    _lastSeq[gestureId] = seq;

    setState(() {
      latencies.insert(0, latency);
      if (latencies.length > maxLatSamples) latencies.removeLast();
    });

    if (isFinal) _gestureStates[gestureId] = 'done';
  }

  void _sendToWorker(Map<String, dynamic> msg) {
    if (_outgoingQueue.length >= maxQueueSize) {
      _outgoingQueue.removeFirst();
    }
    _outgoingQueue.add(msg);
    _workerPort?.send(_outgoingQueue.removeFirst());
  }

  void _handlePointerDown(PointerDownEvent e) {
    _gestureIdCounter++;
    _currentGestureId = _gestureIdCounter;
    _gestureStates[_currentGestureId] = 'active';
    _classifier.reset();
  }

  void _handlePointerMove(PointerMoveEvent e) {
    final now = DateTime.now().millisecondsSinceEpoch;
    if (now - _lastCoalesceTime < coalesceWindowMs) return;
    _lastCoalesceTime = now;

    final sw = Stopwatch()..start();

    setState(() {
      _points.add(e.localPosition);
      if (_points.length > 800) _points.removeRange(0, _points.length - 800);
    });

    final classification = _classifier.classify(e);
    final seq = ++_seqCounter;

    if (!useFastPath) {
      _simulateHeavyBlocking();
    } else if (classification == GestureType.heavy) {
      final msg = {
        'gestureId': _currentGestureId,
        'seq': seq,
        'type': 'move',
        'dx': e.localDelta.dx,
        'dy': e.localDelta.dy,
      };
      _sendToWorker(msg);
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      sw.stop();
      final ms = sw.elapsedMilliseconds;
      setState(() {
        latencies.insert(0, ms);
        if (latencies.length > maxLatSamples) latencies.removeLast();
      });
    });
  }

  void _handlePointerUp(PointerUpEvent e) {
    final gestureId = _currentGestureId;
    _gestureStates[gestureId] = 'cancelled';
    _sendToWorker({
      'gestureId': gestureId,
      'seq': ++_seqCounter,
      'type': 'end',
      'isFinal': true,
    });
  }

  void _simulateHeavyBlocking() {
    final sw = Stopwatch()..start();
    double acc = 0;
    while (sw.elapsedMilliseconds < 35) {
      for (int i = 0; i < 4000; i++) {
        acc += math.sqrt(i * 1.2345);
      }
    }
    if (acc.isNaN) debugPrint('');
  }

  int _percentile(List<int> a, double p) {
    if (a.isEmpty) return 0;
    final sorted = List<int>.from(a)..sort();
    final idx = ((sorted.length - 1) * p).round();
    return sorted[idx];
  }

  @override
  Widget build(BuildContext context) {
    final sorted = [...latencies]..sort();
    final p50 = _percentile(sorted, 0.50);
    final p55 = _percentile(sorted, 0.55);
    final p95 = _percentile(sorted, 0.95);
    final p99 = _percentile(sorted, 0.99);

    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        title: Text(useFastPath
            ? 'âš¡ Fast Path (Phase 2)'
            : 'ðŸ§± Baseline â€” Heavy on UI'),
        actions: [
          TextButton(
            onPressed: () => setState(() {
              latencies.clear();
              useFastPath = !useFastPath;
            }),
            child: Text(
              useFastPath ? 'Switch to Baseline' : 'Switch to Fast Path',
              style: const TextStyle(color: Colors.white),
            ),
          ),
        ],
      ),
      body: Stack(
        children: [
          // GPU animation
          Positioned(
            top: 50,
            right: 50,
            child: SizedBox(
              width: 350,
              height: 350,
              child: Extreme3DAnimation(
                controller: _animationController,
                numSpheres: numSpheres,
                rotationSpeeds: rotationSpeeds,
                phaseOffsets: phaseOffsets,
              ),
            ),
          ),

          // gesture listener
          Listener(
            onPointerDown: _handlePointerDown,
            onPointerMove: _handlePointerMove,
            onPointerUp: _handlePointerUp,
            child: CustomPaint(
              painter: DrawPainter(_points),
              child: Container(color: Colors.transparent),
            ),
          ),

          // mode indicator
          Positioned(
            top: 20,
            left: 20,
            child: Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: useFastPath
                    ? Colors.greenAccent.withOpacity(0.3)
                    : Colors.redAccent.withOpacity(0.3),
                borderRadius: BorderRadius.circular(6),
              ),
              child: Text(
                useFastPath ? 'FAST PATH ACTIVE' : 'BASELINE MODE',
                style: const TextStyle(
                    fontFamily: 'monospace',
                    fontWeight: FontWeight.bold,
                    color: Colors.white),
              ),
            ),
          ),

          // telemetry + slider
          Positioned(
            bottom: 20,
            left: 20,
            child: Container(
              padding: const EdgeInsets.all(12),
              width: 360,
              decoration: BoxDecoration(
                color: Colors.white10,
                borderRadius: BorderRadius.circular(8),
              ),
              child: DefaultTextStyle(
                style: const TextStyle(fontFamily: 'monospace'),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Latency p50/p55/p95/p99: $p50 / $p55 / $p95 / $p99 ms'),
                    const SizedBox(height: 6),
                    Text('Samples: ${latencies.take(10).join(', ')}'),
                    const SizedBox(height: 6),
                    Row(children: [
                      const Text('Spheres: '),
                      Expanded(
                        child: Slider(
                          min: 0,
                          max: 400,
                          divisions: 40,
                          value: numSpheres.toDouble(),
                          onChanged: (v) =>
                              setState(() => numSpheres = v.round()),
                        ),
                      ),
                      Text('$numSpheres'),
                    ]),
                    const SizedBox(height: 10),
                    ElevatedButton(
                      onPressed: () => setState(() => latencies.clear()),
                      child: const Text('Clear Samples'),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// ---------------- FastClassifier ----------------
enum GestureType { light, heavy }

class FastClassifier {
  Offset? lastPos;
  int lastTime = 0;

  GestureType classify(PointerEvent e) {
    final now = DateTime.now().millisecondsSinceEpoch;
    final dt = (now - lastTime).clamp(1, 1000);
    lastTime = now;

    if (lastPos == null) {
      lastPos = e.localPosition;
      return GestureType.light;
    }

    final dx = (e.localPosition - lastPos!).distance;
    lastPos = e.localPosition;
    final velocity = dx / dt;
    final isHeavy = velocity < 0.05 || dx > 40;
    return isHeavy ? GestureType.heavy : GestureType.light;
  }

  void reset() {
    lastPos = null;
    lastTime = 0;
  }
}

// ---------------- Worker isolate ----------------
void _workerEntry(SendPort sendPort) {
  final port = ReceivePort();
  sendPort.send(port.sendPort);

  port.listen((msg) {
    if (msg is Map) {
      final int gestureId = msg['gestureId'] ?? 0;
      final int seq = msg['seq'] ?? 0;
      final bool isFinal = msg['isFinal'] ?? false;

      final sw = Stopwatch()..start();
      double acc = 0;
      for (int i = 0; i < 800000; i++) {
        acc += math.sqrt(i + gestureId + seq);
      }
      sw.stop();

      sendPort.send({
        'gestureId': gestureId,
        'seq': seq,
        'latency': sw.elapsedMilliseconds,
        'isFinal': isFinal,
      });
    }
  });
}

// ---------------- Painter ----------------
class DrawPainter extends CustomPainter {
  final List<Offset> pts;
  DrawPainter(this.pts);

  @override
  void paint(Canvas c, Size s) {
    final p = Paint()
      ..color = Colors.blueAccent.withOpacity(0.5)
      ..strokeWidth = 3
      ..strokeCap = StrokeCap.round;
    for (int i = 1; i < pts.length; i++) {
      c.drawLine(pts[i - 1], pts[i], p);
    }
  }

  @override
  bool shouldRepaint(covariant DrawPainter oldDelegate) => true;
}

// ---------------- 3D Animation ----------------
class Extreme3DAnimation extends StatelessWidget {
  final AnimationController controller;
  final int numSpheres;
  final List<double> rotationSpeeds;
  final List<double> phaseOffsets;

  const Extreme3DAnimation({
    required this.controller,
    required this.numSpheres,
    required this.rotationSpeeds,
    required this.phaseOffsets,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, child) {
        return Transform(
          alignment: Alignment.center,
          transform: Matrix4.identity()..setEntry(3, 2, 0.003),
          child: Stack(
            alignment: Alignment.center,
            children: List.generate(numSpheres, (i) {
              final rs = rotationSpeeds[i % rotationSpeeds.length];
              final ph = phaseOffsets[i % phaseOffsets.length];
              final angle = controller.value * 2 * math.pi * rs + ph;
              final radius = 20 + i % 20 * 8;
              final dx = radius * math.cos(angle);
              final dy = radius * math.sin(angle);
              final size = 15 + (i % 5) * 8.toDouble();;
              return Transform.translate(
                offset: Offset(dx, dy),
                child: Container(
                  width: size,
                  height: size,
                  decoration: BoxDecoration(
                    color: Colors.primaries[i % Colors.primaries.length]
                        .withOpacity(0.4),
                    shape: BoxShape.circle,
                  ),
                ),
              );
            }),
          ),
        );
      },
    );
  }
}
