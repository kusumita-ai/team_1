// fast_path_core.dart
// Public API for fast-path gesture handling. Internals (classifier/worker) are private.

import 'dart:async';
import 'dart:collection';
import 'dart:isolate';
import 'dart:math' as math;
import 'package:flutter/widgets.dart';
import 'package:flutter/material.dart';

/// ----------------- PUBLIC API -----------------
/// Export / use these types from consumer code.

class FastPathConfig {
  final int coalesceWindowMs;
  final int maxQueueSize;
  final int uiBlockingSimMs;
  const FastPathConfig({
    this.coalesceWindowMs = 8,
    this.maxQueueSize = 8,
    this.uiBlockingSimMs = 35,
  });
}

/// Runtime controller (toggle fast-path, dispose)
class FastPathController {
  final _ready = Completer<void>();
  void Function()? _onDispose;
  bool useFastPath = true;
  Future<void> get ready => _ready.future;
  void _markReady() => _ready.complete();
  void _registerDispose(void Function() cb) => _onDispose = cb;
  void dispose() => _onDispose?.call();
  void setUseFastPath(bool v) => useFastPath = v;
}

/// Small event sent to apps for moves
class GestureMove {
  final Offset delta;
  final int seq;
  final int gestureId;
  GestureMove({required this.delta, required this.seq, required this.gestureId});
}

/// Drop-in widget that wraps an interactive area. Apps pass `child`.
/// Apps only need this + FastPathController to integrate.
class FastPathWidget extends StatefulWidget {
  final Widget child;
  final FastPathConfig config;
  final FastPathController? controller;
  final void Function(List<int>)? onLatencySamples;
  final void Function(GestureMove)? onClassifiedMove;
  final void Function(PointerEvent)? onRawPointer;

  const FastPathWidget({
    required this.child,
    this.config = const FastPathConfig(),
    this.controller,
    this.onLatencySamples,
    this.onClassifiedMove,
    this.onRawPointer,
    super.key,
  });

  @override
  State<FastPathWidget> createState() => _FastPathWidgetState();
}

/// ----------------- PRIVATE IMPLEMENTATION -----------------

class _FastPathWidgetState extends State<FastPathWidget> {
  final List<int> _latencies = [];
  static const int _maxLatSamples = 60;

  int _gestureIdCounter = 0;
  int _seqCounter = 0;
  int _currentGestureId = -1;
  final Map<int, String> _gestureStates = {};
  final Map<int, int> _lastSeq = {};

  final Queue<Map<String, dynamic>> _outgoingQueue = Queue();
  int _lastCoalesceTime = 0;

  Isolate? _worker;
  SendPort? _workerPort;
  final ReceivePort _uiReceive = ReceivePort();

  late final _FastClassifier _classifier;
  late final FastPathController _controller;
  late FastPathConfig _cfg;

  @override
  void initState() {
    super.initState();
    _cfg = widget.config;
    _classifier = _FastClassifier();
    _controller = widget.controller ?? FastPathController();
    _controller._registerDispose(_disposeInternals);
    _spawnWorker().then((_) => _controller._markReady());
  }

  Future<void> _spawnWorker() async {
    final ready = Completer<SendPort>();
    _worker = await Isolate.spawn(_workerEntry, _uiReceive.sendPort);
    _uiReceive.listen((msg) {
      if (msg is SendPort) {
        _workerPort = msg;
        ready.complete(msg);
      } else {
        _onWorkerMessage(msg);
      }
    });
    _workerPort = await ready.future;
  }

  void _onWorkerMessage(dynamic msg) {
    if (msg is! Map) return;
    final int gestureId = msg['gestureId'] ?? 0;
    final int seq = msg['seq'] ?? 0;
    final int latency = msg['latency'] ?? 0;
    final bool isFinal = msg['isFinal'] ?? false;

    if (_gestureStates[gestureId] != 'active') return;
    if (seq < (_lastSeq[gestureId] ?? -1)) return;
    _lastSeq[gestureId] = seq;

    _latencies.insert(0, latency);
    if (_latencies.length > _maxLatSamples) _latencies.removeLast();

    widget.onLatencySamples?.call(List<int>.from(_latencies));
    if (isFinal) _gestureStates[gestureId] = 'done';
    // no setState here â€” consumer decides whether to render telemetry
  }

  void _sendToWorker(Map<String, dynamic> msg) {
    if (_outgoingQueue.length >= _cfg.maxQueueSize) {
      _outgoingQueue.removeFirst();
    }
    _outgoingQueue.add(msg);
    _workerPort?.send(_outgoingQueue.removeFirst());
  }

  void _handlePointerDown(PointerDownEvent e) {
    _gestureIdCounter++;
    _currentGestureId = _gestureIdCounter;
    _gestureStates[_currentGestureId] = 'active';
    _classifier.reset();
    widget.onRawPointer?.call(e);
  }

  void _handlePointerMove(PointerMoveEvent e) {
    final now = DateTime.now().millisecondsSinceEpoch;
    if (now - _lastCoalesceTime < _cfg.coalesceWindowMs) return;
    _lastCoalesceTime = now;

    final sw = Stopwatch()..start();

    final classification = _classifier.classify(e);
    final seq = ++_seqCounter;

    if (!(_controller.useFastPath)) {
      _simulateHeavyBlocking(_cfg.uiBlockingSimMs);
    } else if (classification == _GestureType.heavy) {
      final msg = {
        'gestureId': _currentGestureId,
        'seq': seq,
        'type': 'move',
        'dx': e.localDelta.dx,
        'dy': e.localDelta.dy,
      };
      _sendToWorker(msg);
      widget.onClassifiedMove?.call(GestureMove(
        delta: e.localDelta,
        seq: seq,
        gestureId: _currentGestureId,
      ));
    } else {
      // light classification -> immediate small callback
      widget.onClassifiedMove?.call(GestureMove(
        delta: e.localDelta,
        seq: seq,
        gestureId: _currentGestureId,
      ));
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      sw.stop();
      final ms = sw.elapsedMilliseconds;
      _latencies.insert(0, ms);
      if (_latencies.length > _maxLatSamples) _latencies.removeLast();
      widget.onLatencySamples?.call(List<int>.from(_latencies));
    });

    widget.onRawPointer?.call(e);
  }

  void _handlePointerUp(PointerUpEvent e) {
    final gestureId = _currentGestureId;
    _gestureStates[gestureId] = 'cancelled';
    _sendToWorker({
      'gestureId': gestureId,
      'seq': ++_seqCounter,
      'type': 'end',
      'isFinal': true,
    });
    widget.onRawPointer?.call(e);
  }

  void _simulateHeavyBlocking(int ms) {
    final sw = Stopwatch()..start();
    double acc = 0;
    while (sw.elapsedMilliseconds < ms) {
      for (int i = 0; i < 4000; i++) {
        acc += math.sqrt(i * 1.2345);
      }
    }
    if (acc.isNaN) debugPrint('');
  }

  @override
  Widget build(BuildContext context) {
    // Note: keep widget.child on top so developer UI sits under the gesture wrapper.
    return Listener(
      onPointerDown: _handlePointerDown,
      onPointerMove: _handlePointerMove,
      onPointerUp: _handlePointerUp,
      child: widget.child,
    );
  }

  Future<void> _disposeInternals() async {
    _worker?.kill(priority: Isolate.immediate);
    _uiReceive.close();
  }

  @override
  void dispose() {
    _disposeInternals();
    super.dispose();
  }
}

/// ----------------- PRIVATE CLASSIFIER & WORKER -----------------

enum _GestureType { light, heavy }

class _FastClassifier {
  Offset? lastPos;
  int lastTime = 0;
  _GestureType classify(PointerEvent e) {
    final now = DateTime.now().millisecondsSinceEpoch;
    final dt = (now - lastTime).clamp(1, 1000);
    lastTime = now;
    if (lastPos == null) {
      lastPos = e.localPosition;
      return _GestureType.light;
    }
    final dx = (e.localPosition - lastPos!).distance;
    lastPos = e.localPosition;
    final velocity = dx / dt;
    final isHeavy = velocity < 0.05 || dx > 40;
    return isHeavy ? _GestureType.heavy : _GestureType.light;
  }

  void reset() {
    lastPos = null;
    lastTime = 0;
  }
}

// worker entry point (private)
void _workerEntry(SendPort sendPort) {
  final port = ReceivePort();
  sendPort.send(port.sendPort);

  port.listen((msg) {
    if (msg is Map) {
      final int gestureId = msg['gestureId'] ?? 0;
      final int seq = msg['seq'] ?? 0;
      final bool isFinal = msg['isFinal'] ?? false;

      // simulate heavy classification/processing
      final sw = Stopwatch()..start();
      double acc = 0;
      for (int i = 0; i < 800000; i++) {
        acc += math.sqrt(i + gestureId + seq);
      }
      sw.stop();

      sendPort.send({
        'gestureId': gestureId,
        'seq': seq,
        'latency': sw.elapsedMilliseconds,
        'isFinal': isFinal,
      });
    }
  });
}
